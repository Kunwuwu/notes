# [趋势科技+广联达-后台开发-面经](https://www.nowcoder.com/discuss/183215 )

> **打不倒你的终究会使你变强大！！** 

## 趋势科技一面

### 1.简单自我介绍

### 2.多线程

是指从软件或者硬件上实现多个线程并发执行的技术。 具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。 

### 3.多进程

在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。 

### 4.多线程编程需要注意什么问题？

线程安全问题，以及线程的调度和阻塞。

### 5.如何解决线程安全问题？

加锁。

### 6.讲一下锁？

线程之间的锁有：互斥锁、条件锁、自旋锁、读写锁、递归锁。一般而言，锁的功能越强大，性能就会越低。 

1. 互斥锁

   互斥锁就是用于控制多个线程对于他们共享资源的访问，也就是为了避免多个线程同时访问某个资源而导致混乱。任何一个线程都要使用互斥锁互斥访问共享资源（任务队列），访问完后要释放互斥锁。

2. 条件锁

   条件锁就是条件变量。也就是一个线程在符合某种条件时，程序会使用条件变量使得该线程处于阻塞状态。一旦条件允许了，就会唤醒该线程继续执行。比较常见的就是用在线程池中，如果任务队列中暂时没有任务，那么这个线程就会被条件变量设置成阻塞状态。

3. 自旋锁

   自旋锁的作用应该是相对互斥锁而言的。使用互斥锁时，如果线程2访问共享资源发现锁已经被线程1占用，就会被阻塞，执行线程2的CPU就会把线程2放入等待队列，去执行其他任务。而使用自旋锁时，线程2不会被阻塞，会持续地申请自旋锁，这样会一直占用CPU资源。**注意：自旋锁适合于短时间的的轻量级的加锁机制。 **

4. 读写锁

   一次只有一个线程可以占有写模式的读写锁, 但是可以有多个线程同时占有读模式的读写锁。

5. 递归锁

### 7.加锁会出现什么问题？

会出现死锁的问题。

### 8.介绍一下死锁，定义和发生条件？

1. 定义

   死锁是两个或两个以上的线程在执行过程中，由于资源竞争造成的一种阻塞现象。若无外力作用，那死锁状态就会持续下去。

2. 发生条件

   1. 互斥条件

      指线程对某个共享资源访问时，其他线程就不能访问该资源。

   2. 请求和保持条件

      指线程在持有某个资源时，请求访问被占用资源而阻塞时，不会释放自己占用的资源。

   3. 不剥夺条件

      任何资源在被某个线程占用时，其他线程不能剥夺和占用该资源。

   4. 循环等待条件

      发生死锁时，各个线程形成一个资源环路，造成永久阻塞。

3. 如何避免或者解决

   死锁检测、设置超时等。
   
### 9.进程间通信方式

1. 无名管道

   - 父子或兄弟进程之间通信
   - 只存在于内存中
   - 半双工

2. 有名管道

   - 非亲缘关系进程也可以进行通信
   - 以文件形式存在于文件系统中

3. 共享内存

   给多个进程一块共享的存储区域，通常使用信号量来同步对共享内存的访问。

4. 信号量

   用于进程同步，如果要在进程间实现通信需要结合共享内存。

5. 消息队列

   消息队列，是消息的链接表，存放在内核中。 

   - 消息队列是面向记录的，有特定的格式和优先级
   - 独立于发送和接收进程
   - 消息队列可以实现随机查询，不一定要按先进先出的规则读取

### 10. C中数组越界怎么解决？。。。我觉得应该是怎么避免？ 

- 进行越界检查
- 显示地指定数组的边界

### 11.继承有几种方式？

三种，公有、私有、保护。

1. 基类私有成员在派生类中都不可见

2. 继承不能向上提高成员的访问权限，即父类中的protected成员无论通过什么继承方式都不能变成public的
3. 在2的基础上，基类的public和protected成员的访问权限跟随继承方式而变

详细如下表：

![img](assets/1069650-20170409100203972-702164806.png) 

### 12.两种多态讲一下？

![å¨è¿éæå¥å¾çæè¿°](assets/20180919171158694.png) 

### 13.数据库了解吗？

我不了解。。。。2333

### 14.IP地址划分

![img](assets/20190108180005960.png) 

![img](assets/20190108175733102.png) 

### 15. 子网的掩码的作用

子网掩码只有一个作用，就是将某个IP地址划分成[网络地址](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80/9765459)和[主机地址](https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80/9765500)两部分。

### 16.你了解STL的哪些容器？

只是用过一些，没有去看过源码，常用的vector，map，set，list等。

### 17.说一下Hash

1. Hash函数

   哈希就是把任意长度的输入通过哈希算法或者是函数转换成固定长度的输出，也就是散列值。 常用的哈希函数有直接寻址法，平方取中法，数字分析法等。

2. Hash冲突处理

   哈希函数同时一般伴随着哈希冲突，通常处理哈希冲突的方法有开放寻址法，再散列法等。

   开放寻址法（Hi = (H(key) + di) % m）,其中H()为散列函数，di为增量序列，m为表长：

   - 线性探测法，di = 1,2,3,4...
   - 二次方探测法，di = 1,2^2,3^2,4^2...

3. Hash Table 

   哈希表是一种数据结构，将key值通过Hash函数得到一个散列值，该散列值就是key对应的value在数据表数组中的下标或者地址。

## 趋势科技二面

### 1.项目讲讲吧 

我这个是仿照陈硕muduo库实现的一个C++网络库，基于Reactor模式，IO模型是用的非阻塞IO+IO多路复用。

主要用到的技术点有：

- epoll水平触发的IO多路复用技术
- 非阻塞IO，水平触发的话，主要效率提升是提现在发送数据上
- 使用eventfd实现线程的异步缓醒
- 基于(STL set)实现的定时器管理队列
- 禁用Nagle算法，降低延迟
- 实现线程池，避免线程的频繁创建销毁浪费资源
- 主线程只负责接收连接，然后通过Round-robin的方式分发给子线程处理
- 支持shutdown优雅关闭连接
- 使用智能指针来进行对象生命期的管理，减少内存泄露的可能

### 2.项目中遇到过什么问题，代码方面的？

遇到过一次智能指针shared_ptr引用计数变成0，导致对象提前析构的问题。我用了一个map中的一个智能指针指向了一个连接对象，同时一个函数中的临时智能指针也指向了这个连接对象，因为执行的是断开连接的操作，也就是要把这个连接对象从map中删除，所以在删除并执行完这个函数后，引用计数为0，这个连接对象被析构了，但是后面还有一些操作没执行完，所以出错了。后面是通过将这个函数拆成了两个函数，把从map中删除这个操作放在另一个函数中，然后把这个函数注册回调到一个执行队列中，最后把一系列断开连接的操作执行完以后，再去执行队列里，删除这个智能指针，执行队列是在最后执行的。