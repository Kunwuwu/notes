# [西山居三面凉经（C++服务端开发工程师）](https://www.nowcoder.com/discuss/186639 )

## 一面

### 1.自我介绍

### 2.项目

### 3.在校经历

### 4.平时看过什么书？

### 5. 然后手撕一道随机生成一个(1-n)的序列,要求复杂度Ｏ(n)，空间上除了传入的数组不能申请额外空间． 

主要的问题不在于随机生成，而在于如何只利用传入数组实现hash来避免重复。

思路可以这样：

- 假设数组名是nums，数组的大小为n
- 每随机生成一个元素，以其值x为键值，将nums[x]按一定的规律(比如整体-n)变成负数，标记为这个数已经被访问过
- 如果生成的元素x，发现nums[x]已经是负数的话，说明重复了，再次生成，直到nums[x]为非负数为止
- 最后按照之前变成负数的规律，将其再变回非负数

具体操作如下：

- 从左到右遍历数组，假设当前遍历下标为i，对应元素随机为x = rand() % n
- 如果nums[x]为负数，则继续x = rand() % n，直到nums[x]为非负数
- nums[x]为正数了，我们需要将x赋值给nums[i]，但此前需要标记x已经访问过，标记方法如下：
  - 如果x小于i，因为从前往后遍历，说明nums[x]肯定已经被赋值过了，此时直接nums[x] -= n
  - 如果大于等于i，说明还没赋过值，此时直接标记为负数就行，随便多少，因为最后还会被重新赋值
- 标记完x以后，需要给nums[i]赋值，nums[i]赋值需要分两种情况：
  - 如果nums[i]是负数，说明i也是被访问过的，所以赋值nums[i] = x - n
  - 如果不是负数，说明i没有被访问过，所以赋值为nums[i] = x即可
- 最后就会发现，生成了一个范围为[-n, -1]的不重复随机序列，此时直接每个元素+n就得到了[0, n-1]的不重复随机序列

代码：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

void MyRandom(vector<int> &nums) {
    int n = nums.size();
    for (int i = 0; i < n; i++) {
        int x = rand() % n;
        while (nums[x] < 0) x = rand() % n;
        if (x < i)
            nums[x] -= n;
        else
            nums[x] = -n - 1;
        if (nums[i] < 0)
            nums[i] = x - n;
        else nums[i] = x;
    }
    for (int &it : nums) it += n;
}

int main()
{
    vector<int> nums(20);
    MyRandom(nums);

    return 0;
}
```

### 6.模拟十连抽算法？？？不是很懂具体问题

