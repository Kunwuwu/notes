# bbkgl: A High Performance C++ Network Library

## Introduction

bbkgl是一个仿照muduo(木铎)网络库实现的基于Reactor模式以及非阻塞IO的现代C++多线程网络库，整体的思路大体与muduo相同。

## Technical points

- 使用epoll水平触发的IO多路复用技术，非阻塞IO，基于Reactor模式
- 实现了基于二叉搜索树(STL set)的定时器管理队列
- 使用了Linux中的eventfd实现了线程的异步唤醒
- 使用多线程处理连接，充分利用多核处理器的性能
- 主线程只负责接受连接请求，使用Round robin的方式分发给其他IO线程处理
- 使用智能指针等RAII机制减少内存泄漏的可能
- 支持shutdown优雅关闭连接
- 禁用Nagle算法，降低延迟
- 实现了Buffer类，可以既方便又高效率地收发数据

## 可能出现的问题

### 1.项目介绍一下

这个是一个仿照muduo实现的基于Reactor反应堆模式的多线程网络库。主要用到的一些点是，非阻塞IO+（epoll）IO多路复用的IO模型；实现线程池，把接收到的连接分发给空闲的线程处理；用linux中特有的eventfd()去唤醒阻塞在epoll_wait()函数中的线程；禁用了Nagle算法，让小分组数据也独立发送，降低延迟；实现了一个定时器队列，数据结构用的是STL中的set；支持shutdown关闭连接；很多地方用的智能指针去代替普通指针，尽量避免内存泄漏；还实现了IO上的Buffer类，让发送和接受数据更快更方便，Buffer类数据结构用的不是string，是vector。

### 2.介绍一下Reactor模式

Reactor模式是事件驱动的，存在一个或多个输入源，有一个主要的服务器处理器，会将这些连接分发给多个连接处理器去处理。我这个项目中的话，除了本身服务器这个对象外，还有一个接收器，就是Tcp服务器处理对象中的epoll如果检测到新的连接，就会让这个接收器Acceptor去接收新的连接，然后新的连接会分发给工作线程去处理。我的理解的话，Reactor模式就是一个完整的接受-分发-处理的机制。

### 3.epoll原理说一下，和poll以及select对比有什么优劣势？

epoll的话在调用epoll_create函数的时候会在创建一个epoll对象，对象中有一个eventpoll结构体，这个结构体中包含了一棵红黑树和一个双向链表。epoll在整个过程中就是维护这两个数据结构，红黑树的话就是将所有关注的事件都挂载到这个红黑树结点上，然后会给每个事件注册一个回调函数到设备驱动程序上，一旦监测到某个事件活跃，回调函数就会讲活跃的事件添加到双向链表上。epoll_wait函数做的事情就是检查双向链表是否为空，如果为空会阻塞或者返回0，不为空就会把链表上活跃的事件填充到传入的数组中，并返回活跃事件的数量。epoll_ctl()函数就是在红黑树上进行的增删改，还有就是增加结点的时候，可以很快地判断是不是重复。

### 4.定时器数据结构为什么用set，底层是什么，如果碰到时间相同怎么办？

用set主要是考虑自带的排序属性，这里进行了小于号的重载，让set中的定时器按到期时间从小到大排列。定时器队列这个对象也是申请了一个timerfd，然后给队列也设置了一个超时时间，其实就是set第一个元素的到期时间。set底层是红黑树，这里为了防止定时器到期时间可能相同，使用了stl中的pair去包裹时间结构体和定时结构体的指针，所以就算时间可能相同，但是第二个元素的地址肯定不会相同的，set比较的话默认比较第一个元素，相同就比较第二个元素...。

### 5.定时器数据结构还能用什么？

还可以用优先队列或者直接线性表，线性表不好排序，如果经常插入，时间复杂度不适合。优先队列的话一次只能取一个，set的话可以遍历其中元素，一次可以取出很多元素。但是优先队列是一种比较可行的方案，我觉得变成难度会较set低。

### 6.eventfd介绍一下？

linux从2.6以后就支持eventfd了，会返回一个事件驱动的文件描述符。我在这个项目里面主要是用来实现唤醒阻塞的epoll_wait()函数的，当某个线程阻塞，无法自己唤醒的时候。可以通过其他线程调用该线程中一个事件对象的Quit()函数，当检测到非IO线程调用的时候，会直接往eventfd中写入一个字符，然后再epoll中注册可读事件，这样就能唤醒epoll，这些动作都由非IO线程来完成。

### 7.为什么用线程池？

因为线程数量最好是和CPU核心数量相等，这样效率比较高，所以线程池的作用主要是为了控制线程数，避免一个连接一个线程的情况使得线程频繁创建销毁，浪费资源。

### 8.Round-robin讲一下？

Round-robin是一种轮询调度算法，在本项目中是通过轮询每个工作线程，找出下一个线程，然后把新建的连接对象分给这个线程去处理，这里类似于取模的操作，避免过多的连接分给一个线程。

### 9.智能指针用了哪些，还有什么避免内存泄漏的方法？

用了shared_ptr和unique_ptr，前者主要用于指向可以共享的对象，后者用于指向不可共享的对象。new和delete应该成对使用，然后将析构函数声明成虚函数，还有就是重载赋值运算符，重载拷贝构造函数等。

### 10.shutdown()的作用是什么，和close()区别是什么？

close()函数一旦调用了，双方随即断开连接，双方都不能再接受和发送数据。但是shutdown的话是关闭通道，可以选择性关闭输入或者输出的通道，未关闭的通道仍然是正常工作的。close()一旦调用，输出缓冲区即使有数据也不会继续发送了，会立即关闭输出的通道，处于半关闭状态；但是shutdown的话会等待缓冲区中数据发送完成，再关闭输出通道。

- shutdown()仅关闭通道，close()关闭套接字和通道；
- shutdown()只能用于通信套接字，close()可以关闭文件描述符；
- shutdown()等输出缓冲区数据发送完成，再关闭通道，而close()直接关闭；

### 11.Nagle算法是什么？

这个的话我也只是了解，Nagle的算法的作用就是把小分组的数据放在一起变成大分组再发送，这样的话可以节省网络资源，但是会造成延迟。在本项目中是对文件描述符调用setsocketopt()函数，设置TCP_NODELAY参数来禁用Nagle算法。

### 12.介绍一下Buffer类的作用和实现？

Buffer类的作用的话，是结合那个非阻塞IO来体现的。比如说要发送2000KB的数据，但是缓冲区只能接受1500KB的数据，我们对文件描述符设置了非阻塞，所以输出缓冲区满了以后，线程不会阻塞，会继续做其他事情。那这时候剩下的500KB就需要我们去处理了，Buffer类的话主要是出于这个考虑。对于客户，使用这个库的人来说，他希望发送数据就是调用send()函数就行了，就不用管具体是怎么发出去的。Buffer类的话会继续注册一个写事件到epoll中，下次的话，就会继续调用write()函数发送接下来的500KB数据。实现的话参考了muduo的实现，底层用的vector，用读的指针指向起始位置，写的指针指向中间某个位置，然后指针之间的就是可以用来储存要读取的数据，写指针之后的空间用来储存要发送的数据。