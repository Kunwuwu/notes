# Nagle算法

> 参考：[TCP/IP学习笔记（六）Nagle算法](https://blog.csdn.net/sinat_35261315/article/details/79392116)

在TCP传输数据流中，存在两种类型的TCP报文段，一种包含成块数据（通常是满长度的，携带一个报文段最多容纳的字节数），另一种则包含交互数据（通常只有携带几个字节数据）。

对于成块数据的报文段，TCP采用正常的流程发送即可，因为数据利用率很高。而对于交互数据的报文段，数据利用率就显得很低，在网络环境不好的情况下容易加重网络负担。所以TCP必须对交互数据单独处理。

*交互数据实际上就是字节数很少的数据，比如客户端调用10次send操作，每次只发送一个字节的数据。*

## Nagle算法

*nagle算法的核心思想是允许网络中最多只能有一个小分组被发送，而待发送的其它小分组会被重新分组成一个”较大的”小分组，等收到上一个小分组的应答后再发送。*

nagle算法可以减少网络中微小分组的数量，比如客户端需要依次向服务器发送大小为1,2,3,1,2字节的5个分组

在没有开启nagle算法的情况下，这些小分组会被依次发送（不需要等待上一个小分组的应答，因为没启动nagle），总共发送的报文段（分组）个数为5

当开启nagle算法时，客户端首先发送大小为1字节的第一个分组，随后其它分组到达发送缓冲区，由于上一个分组的应答还没有收到，所以TCP会先缓存新来的这4个小分组，并将其重新分组，组成一个大小为8(2+3+1+2)字节的”较大的”小分组。当第一个小分组的应答收到后，客户端将这个8字节的分组发送。总共发送的报文段（分组）个数为2。可以看到，当传输数据存在大量交互数据时，nagle算法可以有效减少网络中的报文段个数

## 禁用Nagle算法

虽然nagle算法可以减少网络中小分组的个数，但是对于那些需要实时预览的通讯程序而言，客户端可能需要不断发送更新数据并得到服务器的响应，这种情况下nagle算法会造成客户端明显的延迟，所以需要禁用nagle算法。

将套接字描述符设置TCP_NODELAY选项可以禁止nagle算法。

```cpp
#include <netinet/tcp.h>
...
    
void cancel_nagle(int fd)
{
    int opt_val = 1;
    setsockopt(fd, SOL_TCP, TCP_NODELAY, &val, sizeof(val));
}
```

