# http长连接和短连接

## Tcp长连接和短连接

http长连接和短连接本质上就是Tcp的长连接和短连接。

1. http 1.0默认使用的是短连接，即建立连接后，进行一次数据交互就断开连接，断开连接由客户端主动发起。如果有新的请求，则需重新建立连接；

2. http 1.1默认使用的是长连接，反应在报文里就是`conection:keep-alive`，这样进行一次数据交互后，连接会继续保持，保持时间由服务器端设置(Tcp保活机制以及应用层心跳包)；

   也就是说是长连接还是短连接，和服务器没有关系，只和客户端有关系，连接能活多久才和服务器端有关系。客户端一次请求成功后断开则是短连接，不断开则是长连接，连接持续时间由服务器端设置。

## Tcp的keep-alive和应用层心跳

前面说了http长连接会一直保持不断开，除非客户端主动操作关闭连接，如果客户端不主动关闭，连接会永久保存。当然这不是最糟糕的，最糟糕的是如果客户端在连接状态下断电了，留下了一个半关闭的连接，而服务器端并不知道客户端崩溃了，这个无效的连接会一直保持。这显然是不科学的，非常浪费资源。于是出现了两种心跳机制，用来解决超时连接问题：

- Tcp的keep-alive，是Tcp提供的一个协议包；
- 应用层心跳，需要开发者自己编写程序实现；

### Tcp的keep-alive

如果服务端和客户端之间超过两个小时没有任何活动的话，服务器就会给客户端发送一个探测包：

1. 如果客户端正常运行，就会正常相应服务端的探测包；而服务端也会重新开始计时，同样是2小时；
2. 如果客户端已经崩溃，无法收到探测包也无法响应。服务端没有收到响应，会在75s后发送探测包，这样的探测包总共10个，10个都没收到响应，服务端会关闭这个连接；
3. 如果客户端因为崩溃后重启，收到了探测包并响应，服务端会收到响应，但该响应是一个复位，连接依然会终止；
4. 客户端正常运行，但其收不到客户端的探测包，无法响应。

显然可以得出结论，Tcp的keep-alive机制存在两个问题：

- 超时时间2小时实在太长了，会占用资源较长时间；
- 无法区分客户端是崩溃了，还是探测包或者是响应包没有成功送达；
- 服务端的服务器程序是不知道存活探测是否发生的，存活探测由Tcp所在的传输层处理，应用层并不知道。

所以，为了解决以上三个问题，应用层心跳就产生了，也就是需要应用层开发者自己开发程序进行心跳检测。

打开keep-alive的代码：

```cpp
int optval = 1;
setsockopt(sockfd_, SOL_SOCKET, SO_KEEPALIVE, &optval, static_cast<socklen_t>(sizeof optval));
```

2019年05月08日16:06更新：
keep-alive可以修改超时探测的时间间隔，具体见[Keep-alive详解](https://www.cnblogs.com/havenshen/p/3850167.html)。

### 应用层心跳

这个不知道怎么写了，各大服务器都实现了，供用户去设置。